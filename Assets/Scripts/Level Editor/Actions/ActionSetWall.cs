using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ActionSetWall : ILevelEditorAction
{
    /// <summary>
    /// Wall anchor the player placed
    /// </summary>
    GameWallAnchor playerWallAnchor;
    /// <summary>
    /// Data for the player's wall anchor at placement
    /// </summary>
    WallAnchorData playerWallData;

    /// <summary>
    /// Wall anchors generated by the editor after the player placed their wall
    /// </summary>
    /// <typeparam name="GameWallAnchor"></typeparam>
    /// <returns></returns>
    List<GameWallAnchor> cpuWallAnchors = new List<GameWallAnchor>();

    /// <summary>
    /// Data for the wall anchors placed by the editor
    /// </summary>
    /// <typeparam name="WallAnchorData"></typeparam>
    /// <returns></returns>
    List<WallAnchorData> cpuWallData = new List<WallAnchorData>();

    /// <summary>
    /// Editor reticle
    /// </summary>
    ReticleController reticle;

    /// <summary>
    /// Position of the reticle once the player placed the wall anchor
    /// </summary>
    Vector3 reticlePosition;

    /// <summary>
    /// Reference to the editor wall placer
    /// </summary>
    SymmetricWallPlacer wallPlacer;

    /// <summary>
    /// Game symmetry at the time of wall setting
    /// </summary>
    SymmetricWallPlacer.WallSymmetry symmetry;

    //TODO: THINK ABOUT THIS...WE NEED TO ACCOUNT FOR CPU PLACED WALLS AS WELL. 

    /// <summary>
    /// Creates an action representing the player setting a wall into place
    /// </summary>
    /// <param name="playerAnchor">Anchor that the player has set</param>
    /// <param name="cpuAnchors">Any anchors generated by the editor as a result of symmetry setting</param>
    /// <param name="symmetry">Symmetry at the time of setting the wall</param>
    /// <param name="reticle">Editor reticle</param>
    public ActionSetWall(GameWallAnchor playerAnchor, List<GameWallAnchor> cpuAnchors, SymmetricWallPlacer wallPlacer, SymmetricWallPlacer.WallSymmetry symmetry, ReticleController reticle)
    {
        //TODO: So...it might have been a good idea to make wall symmetry its own action, but I don't want the player spamming symmetry actions (possibly also clearing an action they wanted kept)
        this.wallPlacer = wallPlacer;
        this.symmetry = symmetry;
        this.reticle = reticle;
        reticlePosition = reticle.transform.position;

        playerWallAnchor = playerAnchor;
        playerWallData.Position = playerAnchor.transform.position;
        playerWallData.LocalScale = playerAnchor.LocalScale;

        foreach (GameWallAnchor anchor in cpuAnchors)
        {
            cpuWallAnchors.Add(anchor);
            WallAnchorData data;
            data.Position = anchor.transform.position;
            data.LocalScale = anchor.LocalScale;
            cpuWallData.Add(data);
        }
    }


    public void RedoAction()
    {
        playerWallAnchor.ShouldScale = false;
        playerWallAnchor.ShouldTrack = false;
        playerWallAnchor.transform.position = playerWallData.Position;
        playerWallAnchor.LocalScale = playerWallData.LocalScale;

        for (int i = 0; i < cpuWallAnchors.Count; i++)
        {
            cpuWallAnchors[i].ShouldScale = false;
            cpuWallAnchors[i].ShouldTrack = false;
            cpuWallAnchors[i].gameObject.SetActive(true);
            cpuWallAnchors[i].LocalScale = cpuWallData[i].LocalScale;
            cpuWallAnchors[i].transform.position = cpuWallData[i].Position;
        }

        reticle.OnStopFlickering.Invoke();
        reticle.transform.position = reticlePosition;
        wallPlacer.Symmetry = symmetry;
    }


    public void UndoAction()
    {
        reticle.OnFlicker.Invoke();
        reticle.transform.position = reticlePosition;

        playerWallAnchor.ShouldScale = true;

        foreach (GameWallAnchor anchor in cpuWallAnchors)
        {
            anchor.gameObject.SetActive(false);
        }
        wallPlacer.Symmetry = symmetry;
    }
}
